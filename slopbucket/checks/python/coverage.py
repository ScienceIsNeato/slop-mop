"""Python coverage analysis check.

Output is designed to be prescriptive for AI agents:
- Shows exactly which lines need tests
- Removes meta-information that doesn't help fix the problem
- Provides copy-paste-ready line references
"""

import os
import re
import sys
import time
from pathlib import Path
from typing import List, Optional, Tuple

from slopbucket.checks.base import (
    BaseCheck,
    ConfigField,
    GateCategory,
    PythonCheckMixin,
)
from slopbucket.core.result import CheckResult, CheckStatus

COVERAGE_THRESHOLD = 80
CI_BUFFER = 0.5  # CI environments get slight buffer for timing variance
COVERAGE_POLL_TIMEOUT = 10  # seconds to wait for coverage.xml
MAX_FILES_TO_SHOW = 5  # Limit files shown to avoid overwhelming output


def _wait_for_coverage_xml(path: str) -> bool:
    """Poll for coverage.xml to appear when running alongside python-tests.

    In parallel mode, python-tests may still be generating .coverage and
    coverage.xml when this check starts.
    """
    deadline = time.time() + COVERAGE_POLL_TIMEOUT
    while time.time() < deadline:
        if os.path.exists(path) and os.path.getsize(path) > 0:
            return True
        time.sleep(0.5)
    return False


def _get_compare_branch() -> str:
    """Resolve the branch to diff against.

    Precedence: COMPARE_BRANCH env â†’ GITHUB_BASE_REF (set in PR CI) â†’ origin/main.
    """
    return (
        os.environ.get("COMPARE_BRANCH")
        or os.environ.get("GITHUB_BASE_REF")
        or "origin/main"
    )


class PythonCoverageCheck(BaseCheck, PythonCheckMixin):
    """Python coverage analysis check.

    Analyzes coverage.xml generated by pytest to verify coverage threshold.
    Default threshold is 80%.
    """

    DEFAULT_THRESHOLD = 80

    @property
    def name(self) -> str:
        return "coverage"

    @property
    def display_name(self) -> str:
        return "ðŸ“Š Coverage (80% threshold)"

    @property
    def category(self) -> GateCategory:
        return GateCategory.PYTHON

    @property
    def depends_on(self) -> List[str]:
        return ["python:tests"]

    @property
    def config_schema(self) -> List[ConfigField]:
        return [
            ConfigField(
                name="threshold",
                field_type="integer",
                default=80,
                description="Minimum coverage percentage required",
                min_value=0,
                max_value=100,
            ),
        ]

    def is_applicable(self, project_root: str) -> bool:
        return self.is_python_project(project_root)

    def run(self, project_root: str) -> CheckResult:
        """Analyze coverage data and provide prescriptive output.

        Instead of meta-information, outputs exactly which lines need tests.
        """
        start_time = time.time()

        # Check for coverage.xml
        coverage_file = Path(project_root) / "coverage.xml"
        if not coverage_file.exists():
            return self._create_result(
                status=CheckStatus.FAILED,
                duration=time.time() - start_time,
                output="",
                error="coverage.xml not found",
                fix_suggestion="Run python-tests check first to generate coverage data",
            )

        # Get coverage report with missing lines
        result = self._run_command(
            [
                sys.executable,
                "-m",
                "coverage",
                "report",
                "--show-missing",
                "--fail-under=0",
            ],
            cwd=project_root,
            timeout=30,
        )

        duration = time.time() - start_time

        # Parse coverage percentage
        coverage_pct = self._parse_coverage(result.output)
        threshold = self.config.get("threshold", self.DEFAULT_THRESHOLD)

        if coverage_pct is None:
            return self._create_result(
                status=CheckStatus.ERROR,
                duration=duration,
                output=result.output,
                error="Could not parse coverage percentage",
            )

        if coverage_pct >= threshold:
            return self._create_result(
                status=CheckStatus.PASSED,
                duration=duration,
                output=f"Coverage: {coverage_pct:.1f}% (threshold: {threshold}%)",
            )

        # Coverage below threshold - provide prescriptive output
        missing_files = self._parse_missing_lines(result.output)
        prescriptive_output = self._format_prescriptive_output(
            coverage_pct, threshold, missing_files
        )

        return self._create_result(
            status=CheckStatus.FAILED,
            duration=duration,
            output=prescriptive_output,
            error=f"Coverage {coverage_pct:.1f}% < {threshold}%",
            fix_suggestion="Add tests for the lines listed above before next iteration.",
        )

    def _parse_missing_lines(self, output: str) -> List[Tuple[str, int, int, str]]:
        """Parse missing line info from coverage report.

        Returns list of (file, stmts, missing_count, missing_lines).
        Sorted by missing_count descending (biggest gaps first).
        """
        results = []
        # Pattern: filename  stmts  miss  cover  missing
        # slopbucket/sb.py   456    386    15%   45-67, 89, 120-150
        pattern = re.compile(r"^(\S+\.py)\s+(\d+)\s+(\d+)\s+\d+%\s+(.+)$", re.MULTILINE)

        for match in pattern.finditer(output):
            filepath = match.group(1)
            stmts = int(match.group(2))
            missing = int(match.group(3))
            missing_lines = match.group(4).strip()

            # Skip files with 100% coverage or no missing lines
            if missing > 0 and missing_lines:
                results.append((filepath, stmts, missing, missing_lines))

        # Sort by missing count (biggest gaps first)
        results.sort(key=lambda x: x[2], reverse=True)
        return results

    def _format_prescriptive_output(
        self,
        coverage_pct: float,
        threshold: int,
        missing_files: List[Tuple[str, int, int, str]],
    ) -> str:
        """Format prescriptive output telling exactly what to do.

        No meta-info, just: "Add tests for these lines"
        """
        lines = []
        lines.append(
            "This commit doesn't meet code coverage standards. "
            "Add high-quality test coverage to the following areas:"
        )
        lines.append("")

        # Show top files with most missing coverage
        for filepath, stmts, missing, missing_lines in missing_files[
            :MAX_FILES_TO_SHOW
        ]:
            lines.append(f"  {filepath}")
            lines.append(f"    Lines: {missing_lines}")
            lines.append("")

        if len(missing_files) > MAX_FILES_TO_SHOW:
            remaining = len(missing_files) - MAX_FILES_TO_SHOW
            lines.append(f"  ... and {remaining} more files")
            lines.append("")

        lines.append(
            "When adding coverage, extend existing tests when possible. "
            "Focus on meaningful assertions, not just line coverage."
        )
        lines.append("")

        return "\n".join(lines)

    def _parse_coverage(self, output: str) -> Optional[float]:
        """Parse coverage percentage from output."""
        # Look for TOTAL line with percentage
        match = re.search(r"TOTAL\s+\d+\s+\d+\s+(\d+(?:\.\d+)?)%", output)
        if match:
            return float(match.group(1))

        # Fallback: look for any percentage
        match = re.search(r"(\d+(?:\.\d+)?)%", output)
        if match:
            return float(match.group(1))

        return None


class PythonDiffCoverageCheck(BaseCheck, PythonCheckMixin):
    """Coverage enforcement on changed files only (diff-cover).

    Uses diff-cover to check coverage on files changed vs compare branch.
    Useful for PRs to ensure new code is tested.
    """

    @property
    def name(self) -> str:
        return "diff-coverage"

    @property
    def display_name(self) -> str:
        return f"ðŸ“ˆ Diff Coverage ({COVERAGE_THRESHOLD}%)"

    @property
    def category(self) -> GateCategory:
        return GateCategory.PYTHON

    @property
    def depends_on(self) -> List[str]:
        return ["python:tests"]

    def is_applicable(self, project_root: str) -> bool:
        return self.is_python_project(project_root)

    def run(self, project_root: str) -> CheckResult:
        start_time = time.time()
        coverage_file = os.path.join(project_root, "coverage.xml")

        if not _wait_for_coverage_xml(coverage_file):
            return self._create_result(
                status=CheckStatus.ERROR,
                duration=time.time() - start_time,
                error="coverage.xml not found",
                fix_suggestion="Run python-tests first to generate coverage data",
            )

        compare_branch = _get_compare_branch()
        cmd = [
            sys.executable,
            "-m",
            "diff_cover.diff_cover_script",
            "coverage.xml",
            f"--compare-branch={compare_branch}",
            f"--fail-under={COVERAGE_THRESHOLD}",
        ]

        result = self._run_command(cmd, cwd=project_root, timeout=60)
        duration = time.time() - start_time

        if result.success:
            return self._create_result(
                status=CheckStatus.PASSED,
                duration=duration,
                output=f"Changed files have adequate coverage (vs {compare_branch})",
            )

        # diff-cover not finding changes is fine
        if "No diff" in result.output:
            return self._create_result(
                status=CheckStatus.PASSED,
                duration=duration,
                output="No changed files to check coverage on",
            )

        return self._create_result(
            status=CheckStatus.FAILED,
            duration=duration,
            output=result.output,
            error=f"Changed files have <{COVERAGE_THRESHOLD}% coverage",
            fix_suggestion="Add tests for the new code shown above.",
        )


class PythonNewCodeCoverageCheck(BaseCheck, PythonCheckMixin):
    """Coverage on new/changed code only â€” CI-oriented diff-cover gate.

    Semantically identical to PythonDiffCoverageCheck but registered
    under the new-code-coverage name that CI workflows reference.
    """

    @property
    def name(self) -> str:
        return "new-code-coverage"

    @property
    def display_name(self) -> str:
        return f"ðŸ†• New Code Coverage ({COVERAGE_THRESHOLD}%)"

    @property
    def category(self) -> GateCategory:
        return GateCategory.PYTHON

    @property
    def depends_on(self) -> List[str]:
        return ["python:tests"]

    def is_applicable(self, project_root: str) -> bool:
        return self.is_python_project(project_root)

    def run(self, project_root: str) -> CheckResult:
        start_time = time.time()
        coverage_file = os.path.join(project_root, "coverage.xml")

        if not _wait_for_coverage_xml(coverage_file):
            return self._create_result(
                status=CheckStatus.ERROR,
                duration=time.time() - start_time,
                error="coverage.xml not found",
                fix_suggestion="Run python-tests first to generate coverage data",
            )

        compare_branch = _get_compare_branch()
        cmd = [
            sys.executable,
            "-m",
            "diff_cover.diff_cover_script",
            "coverage.xml",
            f"--compare-branch={compare_branch}",
            f"--fail-under={COVERAGE_THRESHOLD}",
        ]

        result = self._run_command(cmd, cwd=project_root, timeout=60)
        duration = time.time() - start_time

        if result.success:
            return self._create_result(
                status=CheckStatus.PASSED,
                duration=duration,
                output=f"New code coverage adequate (vs {compare_branch})",
            )

        if "No diff" in result.output:
            return self._create_result(
                status=CheckStatus.PASSED,
                duration=duration,
                output="No changed files to check coverage on",
            )

        return self._create_result(
            status=CheckStatus.FAILED,
            duration=duration,
            output=result.output,
            error=f"New code has <{COVERAGE_THRESHOLD}% coverage",
            fix_suggestion="Add tests for the changed lines shown above.",
        )
